// TODO: merge all the method resolving into a single method, that resolves based on the mangled name, context, method overloading, parameters, etc, every possibility, so the full method signature. So all the methods are resolved equally
// TODO: Unify all the methods definition to a single same type, all the methods should be generated the same, sothey can be resolved equally by the same resolveMethod method
// So the full method signature of a method depends on all: return type, method name, parameters (named, optional, and sorted - unsorted)
// The expectedContext should be infered by things like:
//      · Where is it called, ex: String.parseFloat(getPi()), should infer the getPi() funcion should return float.
//      · Any other expressions ex: 4f + getPi(). Should infer the expectedType to float
//      · A cast expression ex: (double)getPi(); should of course resolve to double getFloat(){}
//      · Assigns int three = getPi(); should for example get a 'Cannot assign float to int" error, unless the result of pi is explicitly converted to int, or there is an int getFloat();
//      · All these checks should be made in a logical order, descarting unviable methods until theres only one, possible, if theres more give an ambigous call error, and if theres no method available for that combination of method name, parameters, context, etc. (so signature). It should probably go one step back and give another error, for exmaple: int three = getPi();, this wouldnt find any viable method, given the call, so it steps back one, assumes u wanted to call one of the almost viable methods, like float getPi(); and give the cannot assign float to int error, instead of the no methods match, so it should prioritize method signature above the expected type.
// And the method would search the best method match (none if ambiguous) based on the full call context, so the resolve method name should take: the methodName (unmangled, so the raw method call name), the expected type, and the parameters used (and in what ordered and values)

import nebula.io.Console;
alias println = Console.println;

// =====================================
// SECTION 1 — Overload Resolution Tests
// =====================================
class OverloadTests
{
    float getPi() { return 3.14f; }      // float version
    double getPi() { return 3.14159; }   // double version

    float getPi(int x) { return 3.14f + x; }
    double getPi(double x) { return 3.14159 + x; }

    int main()
    {
        // Ambiguous: both float and double overloads viable
        println(getPi());           // ❌ should report ambiguity

        // Explicit cast to float resolves to float overload
        println((float)getPi());    // ✅ OK

        // Contextual double arithmetic resolves to double overload
        println(.0 + getPi());      // ✅ OK

        // Explicit arguments
        println(getPi(1));          // ✅ calls float version // TODO: This isnt working, its giving ambigous call, when it should be able to resolve it, maybe cause the parameters arent being accounted for
        println(getPi(1.0));        // ✅ calls double version // TODO: Same here

        return 0;
    }
}

// =====================================
// SECTION 2 — Constructor / Named Args
// =====================================
class Person
{
    public string name {get; set;}
    public int age {get; set;}

    public Person(string name = "John", int age = 30)
    {
        this.name = name;
        this.age = age;
    }
}

class ConstructorTests
{
    int main()
    {
        Person p1 = new Person();
        Person p2 = new Person("Alice");
        Person p3 = new Person(age: 40);
        Person p4 = new Person(name: "Bob", age: 22);
        Person p5 = new Person("Chris", age: 18);

        // ❌ Duplicate named arg
        Person p6 = new Person(name: "Zoe", name: "Again");

        // ❌ Unknown named arg
        Person p7 = new Person(unknown: 42);

        // ❌ Too many args
        Person p8 = new Person("Alice", 30, 99);

        return 0;
    }
}

// =====================================
// SECTION 3 — String Interpolation
// =====================================
class InterpolationTests
{
    int main()
    {
        string s1 = $"Sum: {1 + 2}";
        string s2 = $"Person: {new Person().name}";
        // ❌ Type mismatch inside interpolation
        string s3 = $"Invalid: {true + 2}"; // TODO: Should give error: cannot assign int to bool, but isnt
        return 0;
    }
}

// =====================================
// SECTION 4 — Loops & Arrays
// =====================================
class LoopArrayTests
{
    int main()
    {
        int[] nums = {1, 2, 3};
        Person[] people = { new Person(), new Person("Ana", 20) };

        foreach (int n in nums)
            println(n);

        foreach (Person p in people)
            println(p.name);

        // ❌ Type mismatch in foreach
        foreach (string s in nums) {}

        // ❌ Undeclared variable in for
        for (i = 0; i < 10; i++) {}

        return 0;
    }
}

// =====================================
// SECTION 5 — Return Type Checks
// =====================================
class ReturnTests
{
    int good1() { return 1; }            // ✅ OK
    void good2() { return; }             // ✅ OK
    int bad1() { return; }               // ❌ Missing return value
    void bad2() { return 42; }           // ❌ Returning value in void
    float bad3() { return 1; }           // ❌ Incompatible return type
    float bad4() { if (true) return 1f; } // ❌ Not all paths return
}

// =====================================
// SECTION 6 — Aliases & Imports
// =====================================
class AliasImportTests
{
    int main()
    {
        println("Aliased print works");
        // ❌ Undefined alias
        x("Broken alias");
        return 0;
    }
}
