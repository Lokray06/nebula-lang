// File: src/main/java/org/lokray/semantic/NebulaLibLoader.java
package org.lokray.util;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.lokray.ndk.dto.*;
import org.lokray.semantic.symbol.*;
import org.lokray.semantic.type.PrimitiveType;
import org.lokray.semantic.type.Type;
import org.lokray.semantic.type.UnresolvedType;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Loads a .neblib JSON file (generated by NdkCompiler) into a Scope.
 */
public class NebulaLibLoader
{
	// Updated method signature and implementation
	public static void loadLibrary(Path libFile, Scope globalScope, Map<String, ClassSymbol> declaredClasses) throws IOException
	{
		String json = Files.readString(libFile);
		Gson g = new GsonBuilder().create();
		LibraryDTO lib = g.fromJson(json, LibraryDTO.class);

		if(lib == null)
		{
			Debug.logError("Unexpected error while loading the library from: " + libFile);
			return;
		}

		for (NamespaceDTO ns : lib.namespaces)
		{
			String fqn = ns.name;
			NamespaceSymbol nsSym = getOrCreateNamespace(fqn, globalScope);
			loadNamespaceDTO(ns, nsSym, globalScope, declaredClasses);
		}
		Debug.logDebug("Loaded ndk symbols from " + libFile.getFileName());
	}

	private static void loadNamespaceDTO(NamespaceDTO dto, NamespaceSymbol parent, Scope globalScope, Map<String, ClassSymbol> declaredClasses)
	{
		String parentFqn = parent.getFqn();
		for (ClassDTO cd : dto.classes)
		{
			ClassSymbol cs = new ClassSymbol(cd.name, parent, cd.isNative, cd.isPublic);
			parent.define(cs);

			String classFqn = parentFqn.isEmpty() ? cd.name : parentFqn + "." + cd.name;
			declaredClasses.put(classFqn, cs); // Add to the global map

			for (MethodDTO md : cd.methods)
			{
				Type returnType = resolveTypeFromString(md.returnType, globalScope);

				// Use the new ParameterDTO list
				List<ParameterSymbol> params = new ArrayList<>();
				for (int i = 0; i < md.parameters.size(); i++)
				{
					ParameterDTO pd = md.parameters.get(i);
					Type paramType = resolveTypeFromString(pd.type, globalScope);

					// We now use the name from the DTO, not a dummy name
					String paramName = pd.name;

					// No ExpressionContext available for default value (pass null)
					ParameterSymbol ps = new ParameterSymbol(paramName, paramType, i, null);
					params.add(ps);
				}

				boolean isConstructor = md.name.equals(cd.name);
				boolean isNative = md.isNative;

				MethodSymbol ms = new MethodSymbol(md.name, isConstructor ? cs.getType() : returnType, params, cs, md.isStatic, md.isPublic, isConstructor, isNative);

				// IMPORTANT: Define the parameters in the method's scope
				for (ParameterSymbol ps : params)
				{
					ms.define(ps);
				}

				cs.defineMethod(ms);
			}
			for (FieldDTO fd : cd.fields)
			{
				Type fieldType = resolveTypeFromString(fd.type, globalScope);
				VariableSymbol vs = new VariableSymbol(fd.name, fieldType, fd.isStatic, fd.isPublic, fd.isConst, fd.isNative);
				Debug.logDebug("Defined class member " + cd.name + "." + fd.name);
				cs.define(vs);
			}
		}
		for (StructDTO sd : dto.structs)
		{
			StructSymbol ss = new StructSymbol(sd.name, parent, sd.isNative, sd.isPublic);
			parent.define(ss);

			String structFqn = parentFqn.isEmpty() ? sd.name : parentFqn + "." + sd.name;
			declaredClasses.put(structFqn, ss); // Add to the global map

			for (MethodDTO md : sd.methods)
			{
				Type returnType = resolveTypeFromString(md.returnType, globalScope);

				// Use the new ParameterDTO list
				List<ParameterSymbol> params = new ArrayList<>();
				for (int i = 0; i < md.parameters.size(); i++)
				{
					ParameterDTO pd = md.parameters.get(i);
					Type paramType = resolveTypeFromString(pd.type, globalScope);

					// We now use the name from the DTO, not a dummy name
					String paramName = pd.name;

					// No ExpressionContext available for default value (pass null)
					ParameterSymbol ps = new ParameterSymbol(paramName, paramType, i, null);
					params.add(ps);
				}

				boolean isConstructor = md.name.equals(sd.name);
				boolean isNative = md.isNative;

				MethodSymbol ms = new MethodSymbol(md.name, isConstructor ? ss.getType() : returnType, params, ss, md.isStatic, md.isPublic, isConstructor, isNative);

				// IMPORTANT: Define the parameters in the method's scope
				for (ParameterSymbol ps : params)
				{
					ms.define(ps);
				}

				ss.defineMethod(ms);
			}
			for (FieldDTO fd : sd.fields)
			{
				Type fieldType = resolveTypeFromString(fd.type, globalScope);
				VariableSymbol vs = new VariableSymbol(fd.name, fieldType, fd.isStatic, fd.isPublic, fd.isConst, fd.isNative);
				Debug.logDebug("Defined struct member " + sd.name + "." + fd.name);
				ss.define(vs);
			}
		}
		for (NamespaceDTO c : dto.namespaces)
		{
			String childFqn = parentFqn.isEmpty() ? c.name : parentFqn + "." + c.name;
			NamespaceSymbol child = getOrCreateNamespace(childFqn, globalScope);
			parent.define(child);
			loadNamespaceDTO(c, child, globalScope, declaredClasses);
		}
	}

	private static NamespaceSymbol getOrCreateNamespace(String fqn, Scope globalScope)
	{
		String[] parts = fqn.split("\\.");
		Scope current = globalScope;
		for (String part : parts)
		{
			Optional<Symbol> next = current.resolveLocally(part);
			if (next.isPresent() && next.get() instanceof NamespaceSymbol)
			{
				current = (NamespaceSymbol) next.get();
			}
			else
			{
				NamespaceSymbol newNs = new NamespaceSymbol(part, current);
				current.define(newNs);
				current = newNs;
			}
		}
		return (NamespaceSymbol) current;
	}

	private static Type resolveTypeFromString(String typeName, Scope globalScope)
	{
		if (typeName == null || typeName.isEmpty())
		{
			return PrimitiveType.VOID;
		}
		// Primitives are defined in the global scope
		Optional<Symbol> typeSymbol = globalScope.resolve(typeName);
		if (typeSymbol.isPresent() && typeSymbol.get().getType() != null)
		{
			return typeSymbol.get().getType();
		}
		// For class types not yet seen (e.g., forward-declared in the lib), use a placeholder
		return new UnresolvedType(typeName);
	}
}