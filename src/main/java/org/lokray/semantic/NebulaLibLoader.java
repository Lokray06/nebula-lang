// File: src/main/java/org/lokray/semantic/NebulaLibLoader.java
package org.lokray.semantic;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.lokray.ndk.dto.ClassDTO;
import org.lokray.ndk.dto.FieldDTO;
import org.lokray.ndk.dto.LibraryDTO;
import org.lokray.ndk.dto.MethodDTO;
import org.lokray.ndk.dto.NamespaceDTO;
import org.lokray.semantic.type.PrimitiveType;
import org.lokray.semantic.type.Type;
import org.lokray.semantic.type.UnresolvedType;
import org.lokray.util.Debug;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Loads a .neblib JSON file (generated by NdkCompiler) into a Scope.
 */
public class NebulaLibLoader
{
	// FIX: Updated method signature and implementation
	public static void loadLibrary(Path libFile, Scope globalScope, Map<String, ClassSymbol> declaredClasses) throws IOException
	{
		String json = Files.readString(libFile);
		Gson g = new GsonBuilder().create();
		LibraryDTO lib = g.fromJson(json, LibraryDTO.class);

		for (NamespaceDTO ns : lib.namespaces)
		{
			String fqn = ns.name;
			NamespaceSymbol nsSym = getOrCreateNamespace(fqn, globalScope);
			loadNamespaceDTO(ns, nsSym, globalScope, declaredClasses);
		}
		Debug.logInfo("Loaded ndk library: " + libFile.getFileName());
	}

	private static void loadNamespaceDTO(NamespaceDTO dto, NamespaceSymbol parent, Scope globalScope, Map<String, ClassSymbol> declaredClasses)
	{
		String parentFqn = parent.getFqn();
		for (ClassDTO cd : dto.classes)
		{
			ClassSymbol cs = new ClassSymbol(cd.name, parent);
			cs.setNative(cd.isNative);
			parent.define(cs);

			String classFqn = parentFqn.isEmpty() ? cd.name : parentFqn + "." + cd.name;
			declaredClasses.put(classFqn, cs); // Add to the global map

			for (MethodDTO md : cd.methods)
			{
				Type returnType = resolveTypeFromString(md.returnType, globalScope);
				List<Type> paramTypes = new ArrayList<>();
				for (String pt : md.paramTypes)
				{
					paramTypes.add(resolveTypeFromString(pt, globalScope));
				}
				// Determine if it's a constructor by matching the name with the class name
				boolean isConstructor = md.name.equals(cd.name);
				MethodSymbol ms = new MethodSymbol(md.name, isConstructor ? cs.getType() : returnType, paramTypes, cs, md.isStatic, true, isConstructor);
				cs.defineMethod(ms);
			}
			for (FieldDTO fd : cd.fields)
			{
				Type fieldType = resolveTypeFromString(fd.type, globalScope);
				VariableSymbol vs = new VariableSymbol(fd.name, fieldType, fd.isStatic, true, true);
				cs.define(vs);
			}
		}
		for (NamespaceDTO c : dto.namespaces)
		{
			String childFqn = parentFqn.isEmpty() ? c.name : parentFqn + "." + c.name;
			NamespaceSymbol child = getOrCreateNamespace(childFqn, globalScope);
			parent.define(child);
			loadNamespaceDTO(c, child, globalScope, declaredClasses);
		}
	}

	private static NamespaceSymbol getOrCreateNamespace(String fqn, Scope globalScope)
	{
		String[] parts = fqn.split("\\.");
		Scope current = globalScope;
		for (String part : parts)
		{
			Optional<Symbol> next = current.resolveLocally(part);
			if (next.isPresent() && next.get() instanceof NamespaceSymbol)
			{
				current = (NamespaceSymbol) next.get();
			}
			else
			{
				NamespaceSymbol newNs = new NamespaceSymbol(part, current);
				current.define(newNs);
				current = newNs;
			}
		}
		return (NamespaceSymbol) current;
	}

	private static Type resolveTypeFromString(String typeName, Scope globalScope)
	{
		if (typeName == null || typeName.isEmpty())
		{
			return PrimitiveType.VOID;
		}
		// Primitives are defined in the global scope
		Optional<Symbol> typeSymbol = globalScope.resolve(typeName);
		if (typeSymbol.isPresent() && typeSymbol.get().getType() != null)
		{
			return typeSymbol.get().getType();
		}
		// For class types not yet seen (e.g., forward-declared in the lib), use a placeholder
		return new UnresolvedType(typeName);
	}
}